package radix

import (
	"crypto/tls"
	"net"
	"time"

	"github.com/mediocregopher/radix/v3"
	"github.com/mediocregopher/radix/v3/trace"
)

// generated by goforward github.com/mediocregopher/radix/v3 github.com/mediocregopher/radix

// Action can perform one or more tasks using a Conn
type Action = radix.Action

// CmdAction is a specific type of Action for which a command is marshaled and
// sent to the server and the command's response is read and unmarshaled into a
// receiver within the CmdAction.
//
// A CmdAction can be used like an Action, but it can also be used by marshaling
// the command and unmarshaling the response manually.
//
// A CmdAction should not be used again once UnmarshalRESP returns successfully
// from it.
type CmdAction = radix.CmdAction

// Cmd is used to perform a redis command and retrieve a result. It should not
// passed into Do more than once. See the package docs on how results are
// unmarshaled into the receiver.
//
//	if err := client.Do(radix.Cmd(nil, "SET", "foo", "bar")); err != nil {
//		panic(err)
//	}
//
//	var fooVal string
//	if err := client.Do(radix.Cmd(&fooVal, "GET", "foo")); err != nil {
//		panic(err)
//	}
//	fmt.Println(fooVal) // "bar"
//
// If the receiver value of Cmd is a primitive, a slice/map, or a struct then a
// pointer must be passed in. It may also be an io.Writer, an
// encoding.Text/BinaryUnmarshaler, or a resp.Unmarshaler.
func Cmd(rcv interface{}, cmd string, args ...string) CmdAction {
	return radix.Cmd(rcv, cmd, args...)
}

// FlatCmd is like Cmd, but the arguments can be of almost any type, and FlatCmd
// will automatically flatten them into a single array of strings. Like Cmd, a
// FlatCmd should not be passed into Do more than once.
//
// FlatCmd does _not_ work for commands whose first parameter isn't a key, or
// (generally) for MSET. Use Cmd for those.
//
//	client.Do(radix.FlatCmd(nil, "SET", "foo", 1))
//	// performs "SET" "foo" "1"
//
//	client.Do(radix.FlatCmd(nil, "SADD", "fooSet", []string{"1", "2", "3"}))
//	// performs "SADD" "fooSet" "1" "2" "3"
//
//	m := map[string]int{"a":1, "b":2, "c":3}
//	client.Do(radix.FlatCmd(nil, "HMSET", "fooHash", m))
//	// performs "HMSET" "foohash" "a" "1" "b" "2" "c" "3"
//
//	// FlatCmd also supports using a resp.LenReader (an io.Reader with a Len()
//	// method) as an argument. *bytes.Buffer is an example of a LenReader,
//	// and the resp package has a NewLenReader function which can wrap an
//	// existing io.Reader. For example, if writing an http.Request body:
//	bl := resp.NewLenReader(req.Body, req.ContentLength)
//	client.Do(radix.FlatCmd(nil, "SET", "fooReq", bl))
//
// FlatCmd also supports encoding.Text/BinaryMarshalers. It does _not_ currently
// support resp.Marshaler.
//
// The receiver to FlatCmd follows the same rules as for Cmd.
func FlatCmd(rcv interface{}, cmd, key string, args ...interface{}) CmdAction {
	return radix.FlatCmd(rcv, cmd, key, args...)
}

// MaybeNil is a type which wraps a receiver. It will first detect if what's
// being received is a nil RESP type (either bulk string or array), and if so
// set Nil to true. If not the return value will be unmarshaled into Rcv
// normally.
type MaybeNil = radix.MaybeNil

// EvalScript contains the body of a script to be used with redis' EVAL
// functionality. Call Cmd on a EvalScript to actually create an Action which
// can be run.
type EvalScript = radix.EvalScript

// NewEvalScript initializes a EvalScript instance. numKeys corresponds to the
// number of arguments which will be keys when Cmd is called
func NewEvalScript(numKeys int, script string) EvalScript {
	return radix.NewEvalScript(numKeys, script)
}

// Pipeline returns an Action which first writes multiple commands to a Conn in
// a single write, then reads their responses in a single read. This reduces
// network delay into a single round-trip.
//
// NOTE that, while a Pipeline performs all commands on a single Conn, it
// shouldn't be used for MULTI/EXEC transactions, because if there's an error it
// won't discard the incomplete transaction. Use WithConn or EvalScript for
// transactional functionality instead.
func Pipeline(cmds ...CmdAction) Action {
	return radix.Pipeline(cmds...)
}

// WithConn is used to perform a set of independent Actions on the same Conn.
// key should be a key which one or more of the inner Actions is acting on, or
// "" if no keys are being acted on. The callback function is what should
// actually carry out the inner actions, and the error it returns will be
// passed back up immediately.
//
// NOTE that WithConn only ensures all inner Actions are performed on the same
// Conn, it doesn't make them transactional. Use MULTI/WATCH/EXEC within a
// WithConn for transactions, or use EvalScript
func WithConn(key string, fn func(Conn) error) Action {
	return radix.WithConn(key, fn)
}

// ClusterCanRetryAction is an Action which is aware of Cluster's retry behavior
// in the event of a slot migration. If an Action receives an error from a
// Cluster node which is either MOVED or ASK, and that Action implements
// ClusterCanRetryAction, and the ClusterCanRetry method returns true, then the
// Action will be retried on the correct node.
//
// NOTE that the Actions which are returned by Cmd, FlatCmd, and EvalScript.Cmd
// all implicitly implement this interface.
type ClusterCanRetryAction = radix.ClusterCanRetryAction

// ClusterOpt is an optional behavior which can be applied to the NewCluster
// function to effect a Cluster's behavior
type ClusterOpt = radix.ClusterOpt

// ClusterPoolFunc tells the Cluster to use the given ClientFunc when creating
// pools of connections to cluster members.
func ClusterPoolFunc(pf ClientFunc) ClusterOpt {
	return radix.ClusterPoolFunc(pf)
}

// ClusterSyncEvery tells the Cluster to synchronize itself with the cluster's
// topology at the given interval. On every synchronization Cluster will ask the
// cluster for its topology and make/destroy its connections as necessary.
func ClusterSyncEvery(d time.Duration) ClusterOpt {
	return radix.ClusterSyncEvery(d)
}

// ClusterWithTrace tells the Cluster to trace itself with the given ClusterTrace
// Note that ClusterTrace will block every point that you set to trace.
func ClusterWithTrace(ct trace.ClusterTrace) ClusterOpt {
	return radix.ClusterWithTrace(ct)
}

// Cluster contains all information about a redis cluster needed to interact
// with it, including a set of pools to each of its instances. All methods on
// Cluster are thread-safe
type Cluster = radix.Cluster

// NewCluster initializes and returns a Cluster instance. It will try every
// address given until it finds a usable one. From there it uses CLUSTER SLOTS
// to discover the cluster topology and make all the necessary connections.
//
// NewCluster takes in a number of options which can overwrite its default
// behavior. The default options NewCluster uses are:
//
//	ClusterPoolFunc(DefaultClientFunc)
//	ClusterSyncEvery(5 * time.Second)
//
func NewCluster(clusterAddrs []string, opts ...ClusterOpt) (*Cluster, error) {
	return radix.NewCluster(clusterAddrs, opts...)
}

// CRC16 returns checksum for a given set of bytes based on the crc algorithm
// defined for hashing redis keys in a cluster setup
func CRC16(buf []byte) uint16 {
	return radix.CRC16(buf)
}

// ClusterSlot returns the slot number the key belongs to in any redis cluster,
// taking into account key hash tags
func ClusterSlot(key []byte) uint16 {
	return radix.ClusterSlot(key)
}

// ClusterNode describes a single node in the cluster at a moment in time.
type ClusterNode = radix.ClusterNode

// ClusterTopo describes the cluster topology at a given moment. It will be
// sorted first by slot number of each node and then by secondary status, so
// primaries will come before secondaries.
type ClusterTopo = radix.ClusterTopo

// ErrPoolEmpty is used by Pools created using the PoolOnEmptyErrAfter option
var ErrPoolEmpty = radix.ErrPoolEmpty

// PoolOpt is an optional behavior which can be applied to the NewPool function
// to effect a Pool's behavior
type PoolOpt = radix.PoolOpt

// PoolConnFunc tells the Pool to use the given ConnFunc when creating new
// Conns to its redis instance. The ConnFunc can be used to set timeouts,
// perform AUTH, or even use custom Conn implementations.
func PoolConnFunc(cf ConnFunc) PoolOpt {
	return radix.PoolConnFunc(cf)
}

// PoolPingInterval specifies the interval at which a ping event happens. On
// each ping event the Pool calls the PING redis command over one of it's
// available connections.
//
// Since connections are used in LIFO order, the ping interval * pool size is
// the duration of time it takes to ping every connection once when the pool is
// idle.
//
// A shorter interval means connections are pinged more frequently, but also
// means more traffic with the server.
func PoolPingInterval(d time.Duration) PoolOpt {
	return radix.PoolPingInterval(d)
}

// PoolRefillInterval specifies the interval at which a refill event happens. On
// each refill event the Pool checks to see if it is full, and if it's not a
// single connection is created and added to it.
func PoolRefillInterval(d time.Duration) PoolOpt {
	return radix.PoolRefillInterval(d)
}

// PoolOnEmptyWait effects the Pool's behavior when there are no available
// connections in the Pool. The effect is to cause actions to block as long as
// it takes until a connection becomes available.
func PoolOnEmptyWait() PoolOpt {
	return radix.PoolOnEmptyWait()
}

// PoolOnEmptyCreateAfter effects the Pool's behavior when there are no
// available connections in the Pool. The effect is to cause actions to block
// until a connection becomes available or until the duration has passed. If the
// duration is passed a new connection is created and used.
//
// If wait is 0 then a new connection is created immediately upon an empty Pool.
func PoolOnEmptyCreateAfter(wait time.Duration) PoolOpt {
	return radix.PoolOnEmptyCreateAfter(wait)
}

// PoolOnEmptyErrAfter effects the Pool's behavior when there are no
// available connections in the Pool. The effect is to cause actions to block
// until a connection becomes available or until the duration has passed. If the
// duration is passed then ErrEmptyPool is returned.
//
// If wait is 0 then ErrEmptyPool is returned immediately upon an empty Pool.
func PoolOnEmptyErrAfter(wait time.Duration) PoolOpt {
	return radix.PoolOnEmptyErrAfter(wait)
}

// PoolOnFullClose effects the Pool's behavior when it is full. The effect is to
// cause any connection which is being put back into a full pool to be closed
// and discarded.
func PoolOnFullClose() PoolOpt {
	return radix.PoolOnFullClose()
}

// PoolOnFullBuffer effects the Pool's behavior when it is full. The effect is
// to give the pool an additional buffer for connections, called the overflow.
// If a connection is being put back into a full pool it will be put into the
// overflow. If the overflow is also full then the connection will be closed and
// discarded.
//
// drainInterval specifies the interval at which a drain event happens. On each
// drain event a connection will be removed from the overflow buffer (if any are
// present in it), closed, and discarded.
//
// If drainInterval is zero then drain events will never occur.
func PoolOnFullBuffer(size int, drainInterval time.Duration) PoolOpt {
	return radix.PoolOnFullBuffer(size, drainInterval)
}

// PoolPipelineConcurrency sets the maximum number of pipelines that can be
// executed concurrently.
//
// If limit is greater than the pool size or less than 1, the limit will be
// set to the pool size.
func PoolPipelineConcurrency(limit int) PoolOpt {
	return radix.PoolPipelineConcurrency(limit)
}

// PoolPipelineWindow sets the duration after which internal pipelines will be
// flushed and the maximum number of commands that can be pipelined before
// flushing.
//
// If window is zero then automatic pipelining will be disabled.
// If limit is zero then no limit will be used and pipelines will only be limited
// by the specified time window.
func PoolPipelineWindow(window time.Duration, limit int) PoolOpt {
	return radix.PoolPipelineWindow(window, limit)
}

// PoolWithTrace tells the Pool to trace itself with the given PoolTrace
// Note that PoolTrace will block every point that you set to trace.
func PoolWithTrace(pt trace.PoolTrace) PoolOpt {
	return radix.PoolWithTrace(pt)
}

// Pool is a semi-dynamic pool which holds a fixed number of connections open
// and which implements the Client interface. It takes in a number of options
// which can effect its specific behavior, see the NewPool method.
type Pool = radix.Pool

// NewPool creates a *Pool which will keep open at least the given number of
// connections to the redis instance at the given address.
//
// NewPool takes in a number of options which can overwrite its default
// behavior. The default options NewPool uses are:
//
//	PoolConnFunc(DefaultConnFunc)
//	PoolOnEmptyCreateAfter(1 * time.Second)
//	PoolRefillInterval(1 * time.Second)
//	PoolOnFullBuffer((size / 3)+1, 1 * time.Second)
//	PoolPingInterval(5 * time.Second / (size+1))
//	PoolPipelineConcurrency(size)
//	PoolPipelineWindow(150 * time.Microsecond, 0)
//
func NewPool(network, addr string, size int, opts ...PoolOpt) (*Pool, error) {
	return radix.NewPool(network, addr, size, opts...)
}

// PubSubMessage describes a message being published to a subscribed channel
type PubSubMessage = radix.PubSubMessage

// PubSubConn wraps an existing Conn to support redis' pubsub system.
// User-created channels can be subscribed to redis channels to receive
// PubSubMessages which have been published.
//
// If any methods return an error it means the PubSubConn has been Close'd and
// subscribed msgCh's will no longer receive PubSubMessages from it. All methods
// are threadsafe and non-blocking.
//
// NOTE if any channels block when being written to they will block all other
// channels from receiving a publish.
type PubSubConn = radix.PubSubConn

// PubSub wraps the given Conn so that it becomes a PubSubConn. The passed in
// Conn should not be used after this call.
func PubSub(rc Conn) PubSubConn {
	return radix.PubSub(rc)
}

// PersistentPubSub is like PubSub, but instead of taking in an existing Conn to
// wrap it will create one on the fly. If the connection is ever terminated then
// a new one will be created using the connFn (which defaults to DefaultConnFunc
// if nil) and will be reset to the previous connection's state.
//
// This is effectively a way to have a permanent PubSubConn established which
// supports subscribing/unsubscribing but without the hassle of implementing
// reconnect/re-subscribe logic.
//
// None of the methods on the returned PubSubConn will ever return an error,
// they will instead block until a connection can be successfully reinstated.
func PersistentPubSub(network, addr string, connFn ConnFunc) PubSubConn {
	return radix.PersistentPubSub(network, addr, connFn)
}

// PubSubStub returns a (fake) Conn, much like Stub does, which pretends it is a
// Conn to a real redis instance, but is instead using the given callback to
// service requests. It is primarily useful for writing tests.
//
// PubSubStub differes from Stub in that Encode calls for (P)SUBSCRIBE,
// (P)UNSUBSCRIBE, MESSAGE, and PING will be intercepted and handled as per
// redis' expected pubsub functionality. A PubSubMessage may be written to the
// returned channel at any time, and if the PubSubStub has had (P)SUBSCRIBE
// called matching that PubSubMessage it will be written to the PubSubStub's
// internal buffer as expected.
//
// This is intended to be used so that it can mock services which can perform
// both normal redis commands and pubsub (e.g. a real redis instance, redis
// sentinel). Once created this stub can be passed into PubSub and treated like
// a real connection.
func PubSubStub(remoteNetwork, remoteAddr string, fn func([]string) interface{}) (Conn, chan<- PubSubMessage) {
	return radix.PubSubStub(remoteNetwork, remoteAddr, fn)
}

// Client describes an entity which can carry out Actions, e.g. a connection
// pool for a single redis instance or the cluster client.
//
// Implementations of Client are expected to be thread-safe, except in cases
// like Conn where they specify otherwise.
type Client = radix.Client

// ClientFunc is a function which can be used to create a Client for a single
// redis instance on the given network/address.
type ClientFunc = radix.ClientFunc

// DefaultClientFunc is a ClientFunc which will return a Client for a redis
// instance using sane defaults.
var DefaultClientFunc = radix.DefaultClientFunc

// Conn is a Client wrapping a single network connection which synchronously
// reads/writes data using the redis resp protocol.
//
// A Conn can be used directly as a Client, but in general you probably want to
// use a *Pool instead
type Conn = radix.Conn

// NewConn takes an existing net.Conn and wraps it to support the Conn interface
// of this package. The Read and Write methods on the original net.Conn should
// not be used after calling this method.
func NewConn(conn net.Conn) Conn {
	return radix.NewConn(conn)
}

// ConnFunc is a function which returns an initialized, ready-to-be-used Conn.
// Functions like NewPool or NewCluster take in a ConnFunc in order to allow for
// things like calls to AUTH on each new connection, setting timeouts, custom
// Conn implementations, etc... See the package docs for more details.
type ConnFunc = radix.ConnFunc

// DefaultConnFunc is a ConnFunc which will return a Conn for a redis instance
// using sane defaults.
var DefaultConnFunc = radix.DefaultConnFunc

// DialOpt is an optional behavior which can be applied to the Dial function to
// effect its behavior, or the behavior of the Conn it creates.
type DialOpt = radix.DialOpt

// DialConnectTimeout determines the timeout value to pass into net.DialTimeout
// when creating the connection. If not set then net.Dial is called instead.
func DialConnectTimeout(d time.Duration) DialOpt {
	return radix.DialConnectTimeout(d)
}

// DialReadTimeout determines the deadline to set when reading from a dialed
// connection. If not set then SetReadDeadline is never called.
func DialReadTimeout(d time.Duration) DialOpt {
	return radix.DialReadTimeout(d)
}

// DialWriteTimeout determines the deadline to set when writing to a dialed
// connection. If not set then SetWriteDeadline is never called.
func DialWriteTimeout(d time.Duration) DialOpt {
	return radix.DialWriteTimeout(d)
}

// DialTimeout is the equivalent to using DialConnectTimeout, DialReadTimeout,
// and DialWriteTimeout all with the same value.
func DialTimeout(d time.Duration) DialOpt {
	return radix.DialTimeout(d)
}

// DialAuthPass will cause Dial to perform an AUTH command once the connection
// is created, using the given pass.
//
// If this is set and a redis URI is passed to Dial which also has a password
// set, this takes precedence.
func DialAuthPass(pass string) DialOpt {
	return radix.DialAuthPass(pass)
}

// DialSelectDB will cause Dial to perform a SELECT command once the connection
// is created, using the given database index.
//
// If this is set and a redis URI is passed to Dial which also has a database
// index set, this takes precedence.
func DialSelectDB(db int) DialOpt {
	return radix.DialSelectDB(db)
}

// DialUseTLS will cause Dial to perform a TLS handshake using the provided
// config. If config is nil the config is interpreted as equivalent to the zero
// configuration. See https://golang.org/pkg/crypto/tls/#Config
func DialUseTLS(config *tls.Config) DialOpt {
	return radix.DialUseTLS(config)
}

// Dial is a ConnFunc which creates a Conn using net.Dial and NewConn. It takes
// in a number of options which can overwrite its default behavior as well.
//
// In place of a host:port address, Dial also accepts a URI, as per:
// 	https://www.iana.org/assignments/uri-schemes/prov/redis
// If the URI has an AUTH password or db specified Dial will attempt to perform
// the AUTH and/or SELECT as well.
//
// If either DialAuthPass or DialSelectDB is used it overwrites the associated
// value passed in by the URI.
//
// The default options Dial uses are:
//
//	DialTimeout(10 * time.Second)
//
func Dial(network, addr string, opts ...DialOpt) (Conn, error) {
	return radix.Dial(network, addr, opts...)
}

// Scanner is used to iterate through the results of a SCAN call (or HSCAN,
// SSCAN, etc...)
//
// Once created, repeatedly call Next() on it to fill the passed in string
// pointer with the next result. Next will return false if there's no more
// results to retrieve or if an error occurred, at which point Close should be
// called to retrieve any error.
type Scanner = radix.Scanner

// ScanOpts are various parameters which can be passed into ScanWithOpts. Some
// fields are required depending on which type of scan is being done.
type ScanOpts = radix.ScanOpts

// ScanAllKeys is a shortcut ScanOpts which can be used to scan all keys
var ScanAllKeys = radix.ScanAllKeys

// NewScanner creates a new Scanner instance which will iterate over the redis
// instance's Client using the ScanOpts.
//
// NOTE if Client is a *Cluster this will not work correctly, use the NewScanner
// method on Cluster instead.
func NewScanner(c Client, o ScanOpts) Scanner {
	return radix.NewScanner(c, o)
}

// SentinelOpt is an optional behavior which can be applied to the NewSentinel
// function to effect a Sentinel's behavior.
type SentinelOpt = radix.SentinelOpt

// SentinelConnFunc tells the Sentinel to use the given ConnFunc when connecting
// to sentinel instances.
//
// NOTE that if SentinelConnFunc is not used then Sentinel will attempt to
// retrieve AUTH and SELECT information from the address provided to
// NewSentinel, and use that for dialing all Sentinels. If SentinelConnFunc is
// provided, however, those options must be given through
// DialAuthPass/DialSelectDB within the ConnFunc.
func SentinelConnFunc(cf ConnFunc) SentinelOpt {
	return radix.SentinelConnFunc(cf)
}

// SentinelPoolFunc tells the Sentinel to use the given ClientFunc when creating
// a pool of connections to the sentinel's primary.
func SentinelPoolFunc(pf ClientFunc) SentinelOpt {
	return radix.SentinelPoolFunc(pf)
}

// Sentinel is a Client which, in the background, connects to an available
// sentinel node and handles all of the following:
//
// * Creates a pool to the current primary instance, as advertised by the
// sentinel
//
// * Listens for events indicating the primary has changed, and automatically
// creates a new Client to the new primary
//
// * Keeps track of other sentinels in the cluster, and uses them if the
// currently connected one becomes unreachable
//
type Sentinel = radix.Sentinel

// NewSentinel creates and returns a *Sentinel instance. NewSentinel takes in a
// number of options which can overwrite its default behavior. The default
// options NewSentinel uses are:
//
//	SentinelConnFunc(DefaultConnFunc)
//	SentinelPoolFunc(DefaultClientFunc)
//
func NewSentinel(primaryName string, sentinelAddrs []string, opts ...SentinelOpt) (*Sentinel, error) {
	return radix.NewSentinel(primaryName, sentinelAddrs, opts...)
}

// StreamEntryID represents an ID used in a Redis stream with the format <time>-<seq>.
type StreamEntryID = radix.StreamEntryID

// StreamEntry is an entry in a Redis stream as returned by XRANGE, XREAD and XREADGROUP.
type StreamEntry = radix.StreamEntry

// StreamReaderOpts contains various options given for NewStreamReader that influence the behaviour.
//
// The only required field is Streams.
type StreamReaderOpts = radix.StreamReaderOpts

// StreamReader allows reading from on or more streams, always returning newer entries
type StreamReader = radix.StreamReader

// NewStreamReader returns a new StreamReader for the given client.
//
// Any changes on opts after calling NewStreamReader will have no effect.
func NewStreamReader(c Client, opts StreamReaderOpts) StreamReader {
	return radix.NewStreamReader(c, opts)
}

// Stub returns a (fake) Conn which pretends it is a Conn to a real redis
// instance, but is instead using the given callback to service requests. It is
// primarily useful for writing tests.
//
// When Encode is called the given value is marshalled into bytes then
// unmarshalled into a []string, which is passed to the callback. The return
// from the callback is then marshalled and buffered interanlly, and will be
// unmarshalled in the next call to Decode.
//
// remoteNetwork and remoteAddr can be empty, but if given will be used as the
// return from the RemoteAddr method.
//
// If the internal buffer is empty then Decode will block until Encode is called
// in a separate go-routine. The SetDeadline and SetReadDeadline methods can be
// used as usual to limit how long Decode blocks. All other inherited net.Conn
// methods will panic.
func Stub(remoteNetwork, remoteAddr string, fn func([]string) interface{}) Conn {
	return radix.Stub(remoteNetwork, remoteAddr, fn)
}
